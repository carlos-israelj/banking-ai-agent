# Documentaci√≥n T√©cnica - Banking AI Agent

**Proyecto:** Agente Conversacional Bancario con IA Generativa  
**Autor:** Carlos Israel Jim√©nez  
**Fecha:** Octubre 2025  
**Versi√≥n:** 1.0.0

---

## Tabla de Contenidos

1. [Arquitectura del Sistema](#arquitectura-del-sistema)
2. [Componentes T√©cnicos](#componentes-t√©cnicos)
3. [Implementaci√≥n de RAG](#implementaci√≥n-de-rag)
4. [Sistema de Herramientas (Tools)](#sistema-de-herramientas-tools)
5. [Seguridad e Infraestructura](#seguridad-e-infraestructura)
6. [Testing y Calidad](#testing-y-calidad)
7. [Deployment y Operaciones](#deployment-y-operaciones)

---

## Arquitectura del Sistema

### Visi√≥n General

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Usuario    ‚îÇ
‚îÇ  (WhatsApp)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Capa de Aplicaci√≥n                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   BankingAgent (Orquestador)         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ Gesti√≥n de conversaci√≥n          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ Control de flujo                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ Gesti√≥n de sesi√≥n                ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚Üì               ‚Üì               ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Gemini    ‚îÇ ‚îÇ   RAG    ‚îÇ  ‚îÇ   Tools   ‚îÇ  ‚îÇ   Security   ‚îÇ
‚îÇ   2.5       ‚îÇ ‚îÇ ChromaDB ‚îÇ  ‚îÇ  (6 APIs) ‚îÇ  ‚îÇ   Manager    ‚îÇ
‚îÇ   Flash     ‚îÇ ‚îÇ + Embeds ‚îÇ  ‚îÇ           ‚îÇ  ‚îÇ              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### Flujo de una Interacci√≥n

```python
1. Usuario env√≠a mensaje por WhatsApp
   ‚Üì
2. BankingAgent recibe input
   ‚Üì
3. Verificaci√≥n de sesi√≥n
   ‚Ä¢ ¬øUsuario autenticado?
   ‚Ä¢ ¬øSesi√≥n expirada?
   ‚Üì
4. Procesamiento con Gemini
   ‚Ä¢ An√°lisis de intenci√≥n
   ‚Ä¢ Decisi√≥n de tool use
   ‚Üì
5a. Si requiere tool:
    ‚Ä¢ Validaci√≥n de auth
    ‚Ä¢ Ejecuci√≥n de tool
    ‚Ä¢ Manejo de errores
    ‚Ä¢ Retry si necesario
    ‚Üì
5b. Si requiere knowledge:
    ‚Ä¢ RAG search en ChromaDB
    ‚Ä¢ Top-K resultados
    ‚Ä¢ Contexto para LLM
    ‚Üì
6. Gemini genera respuesta
   ‚Ä¢ Incorpora resultados
   ‚Ä¢ Formato conversacional
   ‚Üì
7. Validaci√≥n de output
   ‚Ä¢ Sanitizaci√≥n de datos
   ‚Ä¢ Enmascaramiento
   ‚Üì
8. Logging y m√©tricas
   ‚Ä¢ Guardar interacci√≥n
   ‚Ä¢ Actualizar KPIs
   ‚Üì
9. Respuesta al usuario
```

---

## Componentes T√©cnicos

### 1. BankingAgent (Core)

**Archivo:** `src/agent.py`

**Responsabilidades:**
- Gesti√≥n del ciclo de vida de la conversaci√≥n
- Orquestaci√≥n de componentes
- Manejo de estado de sesi√≥n
- Control de errores y fallbacks

**Implementaci√≥n:**

```python
class BankingAgent:
    def __init__(self, api_key: str):
        """Inicializa el agente con todas sus dependencias"""
        self.llm = self._initialize_gemini(api_key)
        self.knowledge_base = KnowledgeBase()
        self.tools_manager = ToolsManager()
        self.security = SecurityManager()
        self.session_data = None
        
    def process_message(self, user_message: str) -> str:
        """
        Procesa un mensaje del usuario.
        
        Flow:
        1. Validar input
        2. Construir contexto
        3. Llamar LLM con tools
        4. Manejar tool calls
        5. Validar output
        6. Retornar respuesta
        """
        # 1. Input validation
        if not self.security.validate_input(user_message):
            return "Mensaje no v√°lido"
        
        # 2. Build context
        context = self._build_context(user_message)
        
        # 3. Call LLM
        try:
            response = self.llm.generate_content(
                contents=context,
                tools=self.tools_manager.get_tool_definitions(),
                safety_settings=SAFETY_SETTINGS
            )
        except Exception as e:
            return self._handle_llm_error(e)
        
        # 4. Handle tool calls
        if response.candidates[0].content.parts[0].function_call:
            tool_result = self._execute_tool(
                response.candidates[0].content.parts[0].function_call
            )
            # Enviar resultado de vuelta al LLM
            final_response = self._continue_with_tool_result(tool_result)
        else:
            final_response = response.text
        
        # 5. Output validation
        final_response = self.security.validate_output(final_response)
        
        # 6. Logging
        self._log_interaction(user_message, final_response)
        
        return final_response
```

---

### 2. Gemini Integration

**Configuraci√≥n:**

```python
import google.generativeai as genai

MODEL_NAME = "gemini-2.0-flash-exp"

GENERATION_CONFIG = {
    "temperature": 0.7,  # Balance creatividad/precisi√≥n
    "top_p": 0.95,
    "top_k": 40,
    "max_output_tokens": 2048,
}

SAFETY_SETTINGS = [
    {
        "category": "HARM_CATEGORY_HARASSMENT",
        "threshold": "BLOCK_MEDIUM_AND_ABOVE"
    },
    {
        "category": "HARM_CATEGORY_HATE_SPEECH",
        "threshold": "BLOCK_MEDIUM_AND_ABOVE"
    }
]

# Inicializaci√≥n
genai.configure(api_key=API_KEY)
model = genai.GenerativeModel(
    model_name=MODEL_NAME,
    generation_config=GENERATION_CONFIG,
    safety_settings=SAFETY_SETTINGS,
    system_instruction=SYSTEM_PROMPT
)
```

**System Prompt:**

Ubicado en `config/prompts.py`:

```python
SYSTEM_PROMPT = """
Eres un asistente virtual del Banco Nacional del Ecuador.

IDENTIDAD:
- Profesional, amigable y emp√°tico
- Experto en productos y servicios bancarios
- Prioriza la seguridad y privacidad del cliente

CAPACIDADES:
1. Responder FAQs sobre productos bancarios
2. Consultar informaci√≥n personalizada (requiere autenticaci√≥n):
   - Saldos de cuentas
   - Movimientos recientes
   - Informaci√≥n de tarjetas
   - P√≥lizas de seguros

REGLAS DE ORO:
‚ö†Ô∏è  NUNCA reveles informaci√≥n personal sin autenticaci√≥n
‚ö†Ô∏è  Si no est√°s seguro, deriva a asesor humano
‚ö†Ô∏è  No inventes informaci√≥n: usa solo datos de herramientas

FORMATO:
- Conversacional en espa√±ol
- M√°ximo 3 p√°rrafos por respuesta
- Usa emojis moderadamente (üè¶ üí≥ ‚úÖ)
- S√© conciso pero completo

AUTENTICACI√ìN:
Si el usuario solicita informaci√≥n personal:
1. Verifica si est√° autenticado
2. Si no ‚Üí Ofrece autenticaci√≥n con c√©dula + OTP
3. Usa authenticate_user tool
4. Solo despu√©s procede con la consulta
"""
```

---

### 3. Sistema RAG (Retrieval Augmented Generation)

**Arquitectura:**

```
FAQs (JSON)
    ‚Üì
Embeddings Generation
(sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2)
    ‚Üì
Vector Database
(ChromaDB)
    ‚Üì
Semantic Search
(Cosine Similarity)
    ‚Üì
Top-K Results ‚Üí Context for LLM
```

**Implementaci√≥n:**

```python
# src/knowledge.py

from sentence_transformers import SentenceTransformer
import chromadb

class KnowledgeBase:
    def __init__(self):
        self.embedding_model = SentenceTransformer(
            'sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2'
        )
        self.client = chromadb.Client()
        self.collection = self.client.get_or_create_collection(
            name="banking_faqs",
            metadata={"hnsw:space": "cosine"}
        )
        
    def index_documents(self, faqs: List[Dict]):
        """Indexa FAQs en la base vectorial"""
        documents = []
        embeddings = []
        metadatas = []
        ids = []
        
        for i, faq in enumerate(faqs):
            # Combinar pregunta + respuesta para mejor contexto
            text = f"{faq['question']} {faq['answer']}"
            documents.append(text)
            
            # Generar embedding
            embedding = self.embedding_model.encode(text).tolist()
            embeddings.append(embedding)
            
            metadatas.append({
                "category": faq.get("category", "general"),
                "question": faq["question"]
            })
            ids.append(f"faq_{i}")
        
        # Agregar a ChromaDB
        self.collection.add(
            documents=documents,
            embeddings=embeddings,
            metadatas=metadatas,
            ids=ids
        )
        
    def search(self, query: str, top_k: int = 3) -> List[Dict]:
        """B√∫squeda sem√°ntica en la base de conocimiento"""
        
        # Generar embedding de la query
        query_embedding = self.embedding_model.encode(query).tolist()
        
        # Buscar en ChromaDB
        results = self.collection.query(
            query_embeddings=[query_embedding],
            n_results=top_k
        )
        
        # Formatear resultados
        formatted_results = []
        for i in range(len(results['ids'][0])):
            formatted_results.append({
                "question": results['metadatas'][0][i]['question'],
                "answer": results['documents'][0][i],
                "relevance": 1 - results['distances'][0][i],  # Convertir distancia a score
                "category": results['metadatas'][0][i]['category']
            })
        
        return formatted_results
```

**Datos de FAQs:**

```json
// data/faqs.json
[
  {
    "id": 1,
    "category": "horarios",
    "question": "¬øCu√°l es el horario de atenci√≥n?",
    "answer": "Nuestros horarios son: Lunes a Viernes 8:00 AM - 5:00 PM, S√°bados 9:00 AM - 1:00 PM. Los domingos estamos cerrados."
  },
  {
    "id": 2,
    "category": "cuentas",
    "question": "¬øC√≥mo abrir una cuenta de ahorros?",
    "answer": "Para abrir una cuenta necesitas: 1) C√©dula de identidad vigente, 2) Dep√≥sito inicial de $50, 3) Visitar cualquier sucursal o abrir en l√≠nea."
  }
  // ... m√°s FAQs
]
```

---

## Sistema de Herramientas (Tools)

### Tool Calling con Gemini

Gemini soporta function calling nativo. Definimos las tools en formato JSON Schema:

```python
# src/tools.py

TOOL_DEFINITIONS = [
    {
        "name": "authenticate_user",
        "description": "Autentica un usuario usando c√©dula y c√≥digo OTP",
        "parameters": {
            "type": "object",
            "properties": {
                "document_id": {
                    "type": "string",
                    "description": "N√∫mero de c√©dula del usuario"
                },
                "otp_code": {
                    "type": "string",
                    "description": "C√≥digo OTP de 6 d√≠gitos enviado por SMS"
                }
            },
            "required": ["document_id", "otp_code"]
        }
    },
    {
        "name": "get_account_balance",
        "description": "Consulta el saldo de cuentas del usuario autenticado",
        "parameters": {
            "type": "object",
            "properties": {
                "user_id": {
                    "type": "string",
                    "description": "ID del usuario autenticado"
                },
                "account_type": {
                    "type": "string",
                    "enum": ["savings", "checking", "all"],
                    "description": "Tipo de cuenta a consultar"
                }
            },
            "required": ["user_id"]
        }
    }
    // ... m√°s tools
]
```

### Implementaci√≥n de Tools

```python
class ToolsManager:
    def __init__(self):
        self.tools = {
            "authenticate_user": self.authenticate_user,
            "get_account_balance": self.get_account_balance,
            "get_account_movements": self.get_account_movements,
            "get_card_info": self.get_card_info,
            "get_policy_info": self.get_policy_info,
            "search_knowledge_base": self.search_knowledge_base
        }
    
    def execute(self, tool_name: str, parameters: Dict) -> Dict:
        """Ejecuta una tool con manejo de errores"""
        
        if tool_name not in self.tools:
            return {
                "success": False,
                "error": "TOOL_NOT_FOUND"
            }
        
        try:
            result = self.tools[tool_name](**parameters)
            return result
        except Exception as e:
            logger.error(f"Tool {tool_name} failed: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def authenticate_user(self, document_id: str, otp_code: str) -> Dict:
        """
        Simula autenticaci√≥n 2FA.
        En producci√≥n, llamar√≠a al servicio de auth real.
        """
        # Simulaci√≥n
        if document_id == "1234567890" and otp_code == "123456":
            return {
                "success": True,
                "user_id": "USR-12345",
                "user_name": "Juan P√©rez",
                "session_token": secrets.token_urlsafe(32),
                "expires_at": (datetime.now() + timedelta(minutes=15)).isoformat()
            }
        else:
            return {
                "success": False,
                "error": "INVALID_CREDENTIALS"
            }
    
    def get_account_balance(self, user_id: str, account_type: str = "all") -> Dict:
        """
        Consulta saldo de cuentas.
        En producci√≥n, llamar√≠a al core bancario.
        """
        # Simulaci√≥n
        accounts_data = {
            "USR-12345": {
                "savings": {
                    "balance": 5420.50,
                    "currency": "USD",
                    "account_number": "****1234"
                },
                "checking": {
                    "balance": 1250.00,
                    "currency": "USD",
                    "account_number": "****5678"
                }
            }
        }
        
        if user_id not in accounts_data:
            return {
                "success": False,
                "error": "USER_NOT_FOUND"
            }
        
        user_accounts = accounts_data[user_id]
        
        if account_type == "all":
            return {
                "success": True,
                "accounts": [
                    {"type": "savings", **user_accounts["savings"]},
                    {"type": "checking", **user_accounts["checking"]}
                ]
            }
        elif account_type in user_accounts:
            return {
                "success": True,
                "accounts": [
                    {"type": account_type, **user_accounts[account_type]}
                ]
            }
        else:
            return {
                "success": False,
                "error": "ACCOUNT_NOT_FOUND"
            }
```

---

## Seguridad e Infraestructura

### SecurityManager

```python
# src/security.py

import re
from datetime import datetime, timedelta
from typing import Optional, Dict

class SecurityManager:
    def __init__(self):
        self.failed_attempts = {}  # user_id: count
        self.blocked_users = set()
        self.rate_limiter = RateLimiter(max_requests=30, window_seconds=60)
    
    def validate_input(self, user_input: str) -> bool:
        """Valida input del usuario para prevenir ataques"""
        
        # Detectar XSS
        xss_patterns = [
            r'<script',
            r'javascript:',
            r'onerror=',
            r'onclick='
        ]
        for pattern in xss_patterns:
            if re.search(pattern, user_input, re.IGNORECASE):
                logger.warning(f"XSS attempt detected: {user_input[:100]}")
                return False
        
        # Detectar SQL injection
        sql_patterns = [
            r'(union|select|insert|update|delete|drop)\s',
            r';\s*(drop|delete)',
            r'--\s*$'
        ]
        for pattern in sql_patterns:
            if re.search(pattern, user_input, re.IGNORECASE):
                logger.warning(f"SQL injection attempt: {user_input[:100]}")
                return False
        
        return True
    
    def validate_output(self, agent_response: str, authenticated: bool = False) -> str:
        """Valida y sanitiza output del agente"""
        
        # Enmascarar n√∫meros de cuenta si no est√° autenticado
        if not authenticated:
            agent_response = re.sub(
                r'\b\d{10,16}\b', 
                lambda m: '****' + m.group()[-4:], 
                agent_response
            )
        
        # Enmascarar n√∫meros de tarjeta
        agent_response = re.sub(
            r'\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b',
            lambda m: '**** **** **** ' + m.group()[-4:],
            agent_response
        )
        
        return agent_response
    
    def check_rate_limit(self, user_id: str) -> bool:
        """Verifica rate limiting"""
        return self.rate_limiter.check(user_id)
    
    def track_failed_auth(self, user_id: str):
        """Registra intento fallido de autenticaci√≥n"""
        if user_id not in self.failed_attempts:
            self.failed_attempts[user_id] = 0
        
        self.failed_attempts[user_id] += 1
        
        if self.failed_attempts[user_id] >= 3:
            self.blocked_users.add(user_id)
            logger.warning(f"User {user_id} blocked after 3 failed attempts")
    
    def is_blocked(self, user_id: str) -> bool:
        """Verifica si un usuario est√° bloqueado"""
        return user_id in self.blocked_users
```

### Rate Limiter

```python
from collections import defaultdict
import time

class RateLimiter:
    def __init__(self, max_requests: int, window_seconds: int):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests = defaultdict(list)
    
    def check(self, user_id: str) -> bool:
        """Verifica si el usuario puede hacer un request"""
        now = time.time()
        
        # Limpiar requests antiguos
        self.requests[user_id] = [
            req_time for req_time in self.requests[user_id]
            if now - req_time < self.window_seconds
        ]
        
        # Verificar l√≠mite
        if len(self.requests[user_id]) >= self.max_requests:
            return False
        
        # Registrar nuevo request
        self.requests[user_id].append(now)
        return True
```

---

## Testing y Calidad

### Estructura de Tests

```
tests/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ test_agent.py           # Tests del agente principal
‚îú‚îÄ‚îÄ test_rag.py            # Tests del sistema RAG
‚îú‚îÄ‚îÄ test_tools.py          # Tests de las herramientas
‚îú‚îÄ‚îÄ test_security.py       # Tests de seguridad
‚îî‚îÄ‚îÄ test_integration.py    # Tests de integraci√≥n
```

### Ejemplo de Test

```python
# tests/test_agent.py

import pytest
from src.agent import BankingAgent

@pytest.fixture
def agent():
    """Fixture que crea una instancia del agente"""
    return BankingAgent(api_key=os.getenv('GEMINI_API_KEY'))

def test_faq_response(agent):
    """Test: Responde correctamente a FAQ b√°sica"""
    response = agent.process_message("¬øCu√°l es el horario de atenci√≥n?")
    
    assert "8:00" in response or "8 AM" in response.lower()
    assert "lunes" in response.lower() or "monday" in response.lower()

def test_authentication_required(agent):
    """Test: Solicita autenticaci√≥n para consultas sensibles"""
    response = agent.process_message("¬øCu√°l es mi saldo?")
    
    assert "autenticaci√≥n" in response.lower() or "c√©dula" in response.lower()
    assert agent.session_data is None

def test_authentication_flow(agent):
    """Test: Flujo completo de autenticaci√≥n"""
    # Solicitar autenticaci√≥n
    response1 = agent.process_message("Quiero ver mi saldo")
    assert "c√©dula" in response1.lower()
    
    # Autenticar
    response2 = agent.process_message("Mi c√©dula es 1234567890")
    assert "c√≥digo" in response2.lower() or "otp" in response2.lower()
    
    # Enviar OTP
    response3 = agent.process_message("El c√≥digo es 123456")
    assert agent.session_data is not None
    assert agent.session_data["user_id"] == "USR-12345"

def test_security_xss_prevention(agent):
    """Test: Previene ataques XSS"""
    malicious_input = "<script>alert('xss')</script>"
    response = agent.process_message(malicious_input)
    
    assert "<script>" not in response
    assert "no v√°lido" in response.lower() or "error" in response.lower()
```

### Ejecuci√≥n de Tests

```bash
# Ejecutar todos los tests
pytest tests/ -v

# Con coverage
pytest tests/ --cov=src --cov-report=html

# Tests espec√≠ficos
pytest tests/test_agent.py::test_authentication_flow -v
```

---

## Deployment y Operaciones

### Estructura del Proyecto

```
banking-ai-agent/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ agent.py           # Agente principal
‚îÇ   ‚îú‚îÄ‚îÄ tools.py           # Herramientas
‚îÇ   ‚îú‚îÄ‚îÄ knowledge.py       # Sistema RAG
‚îÇ   ‚îú‚îÄ‚îÄ security.py        # Seguridad
‚îÇ   ‚îî‚îÄ‚îÄ voice_agent.py     # Agente de voz (Caso #2)
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ settings.py        # Configuraci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ prompts.py         # System prompts
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ faqs.json         # Base de conocimiento
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ test_agent.py
‚îÇ   ‚îú‚îÄ‚îÄ test_rag.py
‚îÇ   ‚îî‚îÄ‚îÄ test_tools.py
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ final_report.md
‚îÇ   ‚îú‚îÄ‚îÄ technical_document.md
‚îÇ   ‚îî‚îÄ‚îÄ voice_agent_extension.md
‚îú‚îÄ‚îÄ main.py               # CLI principal
‚îú‚îÄ‚îÄ api.py                # API REST (opcional)
‚îú‚îÄ‚îÄ voice_demo.py         # Demo de voz
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ README.md
```

### Variables de Entorno

```bash
# .env
GEMINI_API_KEY=your_gemini_api_key_here
GOOGLE_APPLICATION_CREDENTIALS=credentials/google-cloud-key.json
LOG_LEVEL=INFO
ENVIRONMENT=development
```

### Instalaci√≥n

```bash
# 1. Clonar repositorio
git clone https://github.com/carlos-israelj/banking-ai-agent.git
cd banking-ai-agent

# 2. Crear entorno virtual
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate   # Windows

# 3. Instalar dependencias
pip install -r requirements.txt

# 4. Configurar variables de entorno
cp .env.example .env
# Editar .env con tus API keys

# 5. Ejecutar
python main.py
```

### Docker (Opcional)

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "api.py"]
```

```bash
# Build
docker build -t banking-ai-agent .

# Run
docker run -p 8000:8000 --env-file .env banking-ai-agent
```

### API REST (Bonus)

```python
# api.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from src.agent import BankingAgent

app = FastAPI(title="Banking AI Agent API")
agent = BankingAgent()

class Message(BaseModel):
    text: str
    session_id: str

@app.post("/chat")
async def chat(message: Message):
    """Endpoint para interacci√≥n con el agente"""
    try:
        response = agent.process_message(message.text)
        return {
            "response": response,
            "session_id": message.session_id
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health():
    """Health check"""
    return {"status": "healthy"}
```

### Logging

```python
# Configuraci√≥n en config/settings.py
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/agent.log'),
        logging.StreamHandler()
    ]
)
```

### Monitoreo

**M√©tricas a monitorear:**
- Latencia (p50, p95, p99)
- Tasa de error
- Uso de cada tool
- Tasa de escalamiento
- CSAT score

**Herramientas sugeridas:**
- Prometheus + Grafana (m√©tricas)
- ELK Stack (logs)
- Sentry (error tracking)

---

## Performance y Optimizaci√≥n

### Optimizaciones Implementadas

1. **Cach√© de embeddings**
   - Evita recalcular embeddings en cada b√∫squeda
   - Reduce latencia del RAG de ~500ms a ~100ms

2. **Connection pooling**
   - Reutiliza conexiones HTTP para Gemini
   - Reduce overhead de SSL handshake

3. **Async operations**
   - Tools que no dependen entre s√≠ se ejecutan en paralelo
   - Reduce latencia en casos con m√∫ltiples tools

4. **Prompt optimization**
   - Prompts concisos pero completos
   - Reduce tokens procesados sin perder calidad

< 